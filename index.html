<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>todo</title>
    <meta name="description" content="Open source todo.txt web app with autocomplete">

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>

    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://apis.google.com https://accounts.google.com https://*.googleapis.com https://*.google.com; style-src 'self' 'unsafe-inline' https://accounts.google.com; img-src 'self' data:; connect-src 'self' https://*.googleapis.com https://accounts.google.com https://apis.google.com https://www.google.com; frame-src 'self' https://accounts.google.com https://content.googleapis.com https://*.google.com;">

    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-hover: #e8e8e8;
            --bg-selected: #dddddd;
            --text-primary: #1a1a1a;
            --text-secondary: #666;
            --border: #ddd;
            --accent: #0066cc;
            --accent-hover: #0052a3;
            --prio-a: #dc3545;
            --prio-b: #fd7e14;
            --prio-c: #ffc107;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --header-height: 57px; /* Höhe der TopBar */
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #1a1a1a;
                --bg-secondary: #2a2a2a;
                --bg-hover: #333;
                --bg-selected: #444444;
                --text-primary: #e8e8e8;
                --text-secondary: #999;
                --border: #444;
                --accent: #4a9eff;
                --accent-hover: #6ab0ff;
            }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html { height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary); color: var(--text-primary);
            font-size: 16px; line-height: 1.5; height: 100%;
            overflow: hidden; position: relative; overscroll-behavior: none;
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr;
            height: 100%; position: relative; overflow: hidden;
        }

        #topBar {
            grid-column: 1 / -1; display: flex; align-items: center;
            padding: 8px 16px; background: var(--bg-secondary);
            border-bottom: 1px solid var(--border); position: sticky;
            top: 0; z-index: 200; gap: 8px;
            height: var(--header-height);
        }
        #topBar .search-add-box {
            flex-grow: 1; min-width: 150px; position: relative;
            display: flex; align-items: center;
        }
        .search-add-box input {
             width: 100%; padding: 10px; border: 2px solid var(--border);
             background: var(--bg-primary); color: var(--text-primary);
             border-radius: 4px; font-size: 14px;
             padding-right: 35px; /* Platz für X */
        }
        .search-add-box input:focus { outline: none; border-color: var(--accent); }

        .clear-search-btn {
            position: absolute; right: 10px; top: 50%;
            transform: translateY(-50%); background: none; border: none;
            font-size: 18px; color: var(--text-secondary); cursor: pointer;
            padding: 0 5px; display: none; z-index: 5;
        }
        .clear-search-btn:hover { color: var(--text-primary); }
        .clear-search-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 1px; border-radius: 50%; }

        .desktop-actions { display: flex; gap: 8px; flex-wrap: nowrap; }
        .burger-btn { display: none; font-size: 24px; padding: 4px 12px; margin-left: auto; }

        #menuPanel {
            display: none; position: fixed; top: 0; right: 0; bottom: 0; width: 280px;
            background: var(--bg-secondary); box-shadow: -2px 0 5px rgba(0,0,0,0.2);
            padding: 60px 20px 20px 20px; flex-direction: column;
            align-items: flex-start; gap: 12px; z-index: 1000; overflow-y: auto;
            overscroll-behavior: contain;
        }
        #menuPanel.menu-open { display: flex; }
        #menuPanel h1 { font-size: 20px; font-weight: 600; margin-bottom: 20px; }
        .close-btn { display: block; position: absolute; top: 10px; right: 10px; font-size: 20px; padding: 4px 10px; background: var(--bg-hover); border: none; }
        #menuPanel .btn, #menuPanel label.btn, #menuPanel a.btn, #menuPanel .sort-controls { width: 100%; text-align: left; }
        #menuPanel .sort-controls { display: flex; flex-direction: column; align-items: flex-start; margin-top: 10px; }
        #menuPanel .sort-controls label { margin-bottom: 4px; font-size: 12px; color: var(--text-secondary); }
        #menuPanel .sort-controls select { padding: 6px 10px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); border-radius: 4px; width: 100%; }

        .btn { padding: 8px 16px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); cursor: pointer; border-radius: 4px; font-size: 14px; transition: all 0.2s; text-decoration: none; display: inline-block; vertical-align: middle; }
        .btn:hover { background: var(--bg-hover); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn:focus-visible, .task-item:focus-visible, input:focus-visible, textarea:focus-visible, select:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
        .btn:active, .task-item:active, .filter-item:active { transform: scale(0.98); }
        .btn-primary { background: var(--accent); color: white; border-color: var(--accent); }
        .btn-primary:hover { background: var(--accent-hover); }

        .sidebar { grid-row: 2; background: var(--bg-secondary); border-right: 1px solid var(--border); overflow-y: auto; padding: 16px; }
        .sidebar-section { margin-bottom: 24px; }
        .sidebar-section h3 { font-size: 12px; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600; }
        .filter-btn, .filter-item { display: flex; justify-content: space-between; align-items: center; width: 100%; text-align: left; padding: 8px 12px; background: none; border: none; color: var(--text-primary); cursor: pointer; border-radius: 4px; margin-bottom: 4px; font-size: 14px; transition: background 0.2s; }
        .filter-btn:hover, .filter-item:hover { background: var(--bg-hover); }
        .filter-btn.active, .filter-item.active { background: var(--accent); color: white; }
        .filter-count { font-size: 12px; color: var(--text-secondary); background: var(--bg-primary); padding: 2px 8px; border-radius: 12px; }
        .filter-item.active .filter-count { background: rgba(255,255,255,0.2); color: white; }

        .main-content {
            grid-row: 2; overflow-y: auto; padding: 0;
            overscroll-behavior: contain; -webkit-overflow-scrolling: touch;
        }

        .task-list-container { padding: 16px 24px; }
        .task-list { display: flex; flex-direction: column; }
        .task-item { display: flex; align-items: flex-start; padding: 12px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 2px; cursor: default; transition: background 0.2s; }
        .task-item:hover { background: var(--bg-hover); }
        .task-item.selected { background: var(--bg-selected); color: var(--text-primary); }
        .task-item.bulk-selected { background: var(--warning); color: var(--text-primary); }
        .task-item:focus { outline: 2px solid var(--accent); outline-offset: -2px; background: var(--bg-selected); }

        .task-group-header { font-size: 14px; font-weight: 600; padding: 8px 12px; background-color: var(--bg-hover); border-bottom: 1px solid var(--border); margin-top: 24px; border-radius: 4px 4px 0 0; }
        .task-group-header:first-of-type { margin-top: 0; }
        .task-item .task-inner-content.hidden { display: none; }
        .task-item .edit-input { padding: 0; margin: 0; border: none; background: transparent; font-family: inherit; cursor: text; font-size: inherit; width: 100%; }
        .task-item.selected .edit-input { background: var(--bg-hover); }
        .task-checkbox { margin-right: 12px; margin-top: 2px; cursor: pointer; flex-shrink: 0; }
        .task-content { flex: 1; min-width: 0; cursor: text; position: relative; }
        .task-text { word-break: break-word; overflow-wrap: break-word; max-width: 100%; }
        .task-text.completed { text-decoration: line-through; opacity: 0.6; }
        .priority { font-weight: 600; margin-right: 4px; }
        .priority-A { color: var(--prio-a); } .priority-B { color: var(--prio-b); } .priority-C { color: var(--prio-c); }
        .project, .context { color: var(--accent); margin: 0 2px; cursor: pointer; border-radius: 3px; padding: 1px 3px; }
        .project:hover, .context:hover { background-color: var(--bg-hover); text-decoration: underline; }
        .task-meta { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }

        .bulk-actions-bar { display: none; position: fixed; bottom: 0; z-index: 150; left: 280px; right: 0; background: var(--bg-secondary); border-top: 1px solid var(--border); padding: 12px 24px; align-items: center; gap: 16px; }
        .bulk-actions-bar.active { display: flex; }

        .empty-state { text-align: center; padding: 48px 24px; color: var(--text-secondary); }
        input[type="file"] { display: none; }

        @media (max-width: 768px) {
             .app-container { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
             .sidebar { display: none; }
             #topBar { padding: 8px 10px; }
             #topBar .desktop-actions { display: none; }
             .burger-btn { display: block; }
             .main-content { padding-bottom: calc(16px + env(safe-area-inset-bottom)); }
             .task-list-container { padding: 16px; }
             .bulk-actions-bar {
                 left: 0; right: 0; bottom: 0;
                 padding-bottom: calc(12px + env(safe-area-inset-bottom));
             }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div id="topBar">
            <div class="search-add-box">
                <input type="text" id="searchAddInput" class="search-add-input" placeholder="Search, filter, or add a new task...">
                <button class="clear-search-btn" id="clearSearchBtn" aria-label="Clear search" style="display: none;">✕</button>
            </div>
            <div class="desktop-actions">
                 <button class="btn" id="helpBtnDesktop">?</button>
                 <button class="btn" id="undoBtnDesktop" disabled>↶ undo</button>
                 <button class="btn" id="archiveCompletedBtnDesktop">archive</button>
                 <label for="fileInput" class="btn">import</label>
                 <button class="btn" id="exportBtnDesktop">export</button>
                 <button class="btn" id="clearLocalBtnDesktop">clear</button>
                 <button class="btn" id="gdriveLoginBtnDesktop">connect to G-Drive</button>
                 <button class="btn" id="gdrivePushBtnDesktop" style="display: none;">save to G-Drive</button>
                 <button class="btn" id="gdrivePullBtnDesktop" style="display: none;">load from G-Drive</button>
                 <a href="impressum.html" target="_blank" class="btn">Impressum</a>
                 <a href="datenschutz.html" target="_blank" class="btn">Datenschutz</a>
            </div>
            <button class="btn burger-btn" id="burgerBtn" aria-label="Menü öffnen" aria-expanded="false">☰</button>
        </div>

        <div id="menuPanel">
            <h1>todo</h1>
            <button class="btn" id="helpBtnMobile">?</button>
            <button class="btn" id="undoBtnMobile" disabled>↶ undo</button>
            <button class="btn" id="archiveCompletedBtnMobile">archive</button>
            <label for="fileInput" class="btn">import</label>
            <button class="btn" id="exportBtnMobile">export</button>
            <button class="btn" id="clearLocalBtnMobile">clear</button> 
            <button class="btn" id="gdriveLoginBtnMobile">connect to G-Drive</button>
            <button class="btn" id="gdrivePushBtnMobile" style="display: none;">save to G-Drive</button>
            <button class="btn" id="gdrivePullBtnMobile" style="display: none;">load from G-Drive</button>
            <a href="impressum.html" target="_blank" class="btn">Impressum</a>
            <a href="datenschutz.html" target="_blank" class="btn">Datenschutz</a>
            <div class="sort-controls">
                <label for="sortSelect">Sort:</label>
                <select id="sortSelect">
                    <option value="default">default</option>
                    <option value="priority">priority</option>
                    <option value="project">project</option>
                    <option value="context">context</option>
                    <option value="due">due</option>
                </select>
            </div>
            <button class="btn close-btn" id="closeMenuBtn" aria-label="Menü schließen">✕</button>
        </div>

        <input type="file" id="fileInput" accept=".txt,text/plain" style="display: none;">

        <aside class="sidebar">
            <section class="sidebar-section">
                <h3>Views</h3>
                <button class="filter-btn" data-view-filter="all">all</button>
                <button class="filter-btn" data-view-filter="open">open</button>
                <button class="filter-btn" data-view-filter="done">done</button>
            </section>
            <section class="sidebar-section">
                <h3>Filter</h3>
                <button class="filter-btn" data-special-filter="no-due">no due</button>
                <button class="filter-btn" data-special-filter="no-project">no project</button>
                <button class="filter-btn" data-special-filter="no-context">no context</button>
                <button class="filter-btn" data-special-filter="no-prio">no prio</button>
            </section>
            <section class="sidebar-section"><h3>Priorities</h3><div id="prioritiesList"></div></section>
            <section class="sidebar-section"><h3>Projects</h3><div id="projectsList"></div></section>
            <section class="sidebar-section"><h3>Contexts</h3><div id="contextsList"></div></section>
        </aside>

        <main class="main-content">
            <div class="task-list-container">
                <div class="task-list" id="taskList"></div>
                <div class="empty-state" id="emptyState" style="display: none;">
                    <h3>No tasks</h3><p>Add your first task above</p>
                </div>
            </div>
        </main>

        <footer class="bulk-actions-bar" id="bulkBar">
            <span id="bulkCount">0 selected</span>
            <button class="btn" id="bulkSelectAllBtn">Select All</button>
            <button class="btn" id="bulkDeselectBtn">Deselect</button>
            <button class="btn btn-primary" id="bulkCompleteBtn">Complete</button>
            <button class="btn" id="bulkDeleteBtn">Delete</button>
        </footer>
    </div>

    <script>
        window.onerror = (msg, src, ln, col, err) => { console.error('Global error:', {msg, src, ln, col, err}); alert('An error occurred.'); return true; };
        window.onunhandledrejection = (e) => console.error('Unhandled promise rejection:', e.reason);

        const app = {
            tasks: [], selectedTask: null, searchQuery: '', sortField: 'default', bulkSelected: new Set(),
            undoStack: [], maxUndoSize: 20, isWaitingForPriority: false, saveDebounceTimer: null,
            CLIENT_ID: '533958879265-u2sipqoup3j5fobgfkq1f37r5g8eo7lj.apps.googleusercontent.com', DRIVE_SCOPE: 'https://www.googleapis.com/auth/drive.appdata',
            DRIVE_FILE_ID: null, gapiClient: null, gisTokenClient: null,

            init() {
                console.log('🚀 Initializing App v2.4.2 (Final + Unminified)'); // Version angepasst
                this.loadFromLocalStorage();
                this.loadUIPreferences();
                this.attachEventListeners();
                this.attachEventDelegation();
                this.autocomplete.init(this);
                this.render();
                this.updateSortSelects();
            },

            updateSortSelects() {
                document.getElementById('sortSelect').value = this.sortField;
            },

            loadFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('todoTxtTasks');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) this.tasks = parsed;
                    }
                } catch (e) { console.error('❌ Failed to load tasks:', e); }
            },

            loadUIPreferences() {
                try { this.sortField = localStorage.getItem('sortField') || 'default'; }
                catch (e) { console.error('⚠️ Failed to load UI preferences:', e); }
            },

            saveToLocalStorage(immediate = false) {
                clearTimeout(this.saveDebounceTimer);
                const save = () => {
                    try { localStorage.setItem('todoTxtTasks', JSON.stringify(this.tasks)); }
                    catch (e) { console.error('❌ Failed to save tasks:', e); }
                };
                if (immediate) { save(); }
                else { this.saveDebounceTimer = setTimeout(save, 300); }
            },

            saveUIPreferences() {
                try { localStorage.setItem('sortField', this.sortField); }
                catch (e) { console.error('⚠️ Failed to save UI preferences:', e); }
            },

            attachEventListeners() {
                const searchAddInput = document.getElementById('searchAddInput');
                const clearSearchBtn = document.getElementById('clearSearchBtn');

                searchAddInput.addEventListener('input', (e) => {
                    this.searchQuery = e.target.value;
                    if (clearSearchBtn) { clearSearchBtn.style.display = e.target.value ? 'block' : 'none'; }
                    this.autocomplete.handleInput(e);
                    this.render();
                });

                searchAddInput.addEventListener('keydown', (e) => {
                    if (this.autocomplete.handleKeydown(e)) { e.preventDefault(); return; }
                    if (e.key === 'Enter' && !e.isComposing) {
                        e.preventDefault();
                        const value = searchAddInput.value.trim();
                        const contextTags = Array.from(value.matchAll(/(?:\s|^)(prio:[\w.-]+|is:[\w.-]+|[\+@][\w.-]+)/g)).map(m => m[1]);
                        const taskText = value.replace(/(?:\s|^)(prio:[\w.-]+|is:[\w.-]+|[\+@][\w.-]+)/g, '').trim();
                        if (taskText) {
                            const fullTaskText = `${taskText} ${contextTags.join(' ')}`.trim();
                            this.addTask(fullTaskText);
                            this.searchQuery = contextTags.join(' ') + (contextTags.length > 0 ? ' ' : '');
                            searchAddInput.value = this.searchQuery;
                             if (clearSearchBtn) { clearSearchBtn.style.display = searchAddInput.value ? 'block' : 'none'; }
                            this.render();
                        }
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (this.searchQuery !== '') {
                            searchAddInput.value = ''; this.searchQuery = '';
                            if (clearSearchBtn) clearSearchBtn.style.display = 'none'; this.render();
                        } else { searchAddInput.blur(); }
                    }
                    if (e.key === 'ArrowDown') {
                        const firstTask = document.querySelector('#taskList .task-item');
                        if (firstTask) {
                            e.preventDefault(); firstTask.focus();
                        }
                    }
                });

                if (clearSearchBtn) {
                    clearSearchBtn.addEventListener('click', () => {
                        searchAddInput.value = ''; this.searchQuery = '';
                        clearSearchBtn.style.display = 'none'; this.render();
                        searchAddInput.focus();
                    });
                } else { console.error("Clear search button not found!"); }

                document.getElementById('sortSelect').addEventListener('change', (e) => this.handleSortChange(e.target.value));

                const addActionListener = (idBase, eventType = 'click', fn) => {
                    const desktopEl = document.getElementById(idBase + 'Desktop');
                    const mobileEl = document.getElementById(idBase + 'Mobile');
                    if (typeof fn !== 'function') { console.error(`Error attaching listener: fn for ${idBase} is not a function.`); return; }
                    const boundFn = fn.bind(this);
                    if (desktopEl) desktopEl.addEventListener(eventType, boundFn);
                    if (mobileEl) mobileEl.addEventListener(eventType, boundFn);
                    if (idBase === 'fileInput' && eventType === 'change') {
                        const fileInput = document.getElementById('fileInput');
                        if (fileInput && !fileInput.dataset.listenerAttached) {
                            fileInput.addEventListener(eventType, boundFn);
                            fileInput.dataset.listenerAttached = 'true';
                        }
                    }
                };

                addActionListener('helpBtn', 'click', this.showHelp);
                addActionListener('undoBtn', 'click', this.undo);
                addActionListener('archiveCompletedBtn', 'click', this.archiveCompleted);
                addActionListener('fileInput', 'change', (e) => { this.importFile(e.target.files[0]); e.target.value = ''; });
                addActionListener('exportBtn', 'click', this.exportToFile);
                addActionListener('clearLocalBtn', 'click', this.clearLocalStorage);
                addActionListener('gdriveLoginBtn', 'click', this.handleAuthClick);
                addActionListener('gdrivePushBtn', 'click', this.pushToDrive);
                addActionListener('gdrivePullBtn', 'click', this.pullFromDrive);

                document.getElementById('bulkSelectAllBtn').addEventListener('click', () => this.bulkSelectAll());
                document.getElementById('bulkDeselectBtn').addEventListener('click', () => this.bulkDeselectAll());
                document.getElementById('bulkCompleteBtn').addEventListener('click', () => this.bulkComplete());
                document.getElementById('bulkDeleteBtn').addEventListener('click', () => this.bulkDelete());

                document.getElementById('burgerBtn').addEventListener('click', () => this.toggleMenu());
                document.getElementById('closeMenuBtn').addEventListener('click', () => this.toggleMenu());

                // --- NEU: Listener zum Schließen des Menüs bei Klick außerhalb ---
                document.addEventListener('click', (e) => {
                    const menu = document.getElementById('menuPanel');
                    const burgerBtn = document.getElementById('burgerBtn');

                    // Prüfen, ob Menü existiert und offen ist
                    if (menu && menu.classList.contains('menu-open')) {
                        // Prüfen, ob der Klick außerhalb des Menüs UND außerhalb des Burger-Buttons war
                        // .closest() prüft, ob das geklickte Element (e.target) selbst das Menü ist oder ein Kind davon.
                        if (!e.target.closest('#menuPanel') && e.target !== burgerBtn) {
                            this.toggleMenu(); // Menü schließen
                        }
                    }
                });

                // Global Keydown Listener
                document.addEventListener('keydown', (e) => {
                    if (!!document.querySelector('.edit-input') || this.autocomplete.active) return;
                    const isTyping = e.target.matches('input, textarea');
                    if (e.key === '/' && !isTyping && document.getElementById('searchAddInput').offsetParent !== null) {
                        e.preventDefault(); document.getElementById('searchAddInput').focus();
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isTyping) { e.preventDefault(); this.undo(); }
                    if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && !isTyping && document.activeElement !== searchAddInput) {
                         e.preventDefault(); this.navigateTasks(e.key === 'ArrowDown' ? 1 : -1);
                    }
                    if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isTyping && this.selectedTask) { e.preventDefault(); this.changePriority(e.key === 'ArrowRight' ? 1 : -1); }
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedTask && !isTyping) { e.preventDefault(); this.deleteTask(this.selectedTask); }
                    if (e.key === 'x' && this.selectedTask && !isTyping) { e.preventDefault(); this.toggleTask(this.selectedTask); }
                    if (e.key === 'e' && this.selectedTask && !isTyping) {
                        e.preventDefault(); const taskElement = document.querySelector(`[data-task-id="${this.selectedTask}"]`); if(taskElement) this.enterEditMode(taskElement);
                    }
                    if (e.key === 'p' && this.selectedTask && !isTyping) { e.preventDefault(); this.isWaitingForPriority = true; }
                });
            },

            handleSortChange(newSortValue) { this.sortField = newSortValue; this.saveUIPreferences(); this.updateSortSelects(); this.render(); },

            attachEventDelegation() {
                const taskList = document.getElementById("taskList");
                taskList.addEventListener("click", e => {
                    if (!!document.querySelector(".edit-input")) return;
                    if (e.target.matches(".project")) { e.stopPropagation(); this.toggleFilter(`+${e.target.textContent.substring(1)}`); return }
                    if (e.target.matches(".context")) { e.stopPropagation(); this.toggleFilter(`@${e.target.textContent.substring(1)}`); return }
                    const taskItem = e.target.closest(".task-item");
                    if (!taskItem) return;
                    const taskId = taskItem.dataset.taskId;
                    if (!taskId) return;
                    if (e.target.matches(".task-checkbox")) { e.preventDefault(); this.toggleTask(taskId); }
                    else if (e.target.closest(".task-content")) { if (e.ctrlKey || e.metaKey) this.toggleBulkSelect(taskId); else this.enterEditMode(taskItem); }
                });
                const sidebar = document.querySelector(".sidebar");
                if (sidebar) sidebar.addEventListener("click", e => {
                    const viewFilterBtn = e.target.closest("[data-view-filter]"); if (viewFilterBtn) this.toggleFilter(`is:${viewFilterBtn.dataset.viewFilter}`, true);
                    const specialFilterBtn = e.target.closest("[data-special-filter]"); if (specialFilterBtn) this.toggleFilter(`is:${specialFilterBtn.dataset.specialFilter}`);
                    const filterItem = e.target.closest(".filter-item"); if (filterItem) { if (filterItem.dataset.priority) this.toggleFilter(`prio:${filterItem.dataset.priority}`); if (filterItem.dataset.project) this.toggleFilter(`+${filterItem.dataset.project}`); if (filterItem.dataset.context) this.toggleFilter(`@${filterItem.dataset.context}`); }
                })
            },

            toggleFilter(filterPart, isViewFilter = false) {
                const parts = new Set(this.searchQuery.split(" ").filter(Boolean));
                const lowerCaseFilterPart = filterPart.toLowerCase();
                let found = false;
                parts.forEach(p => { if (p.toLowerCase() === lowerCaseFilterPart) { parts.delete(p); found = true; } });
                if (!found) {
                    if (isViewFilter || filterPart.startsWith("is:")) { parts.forEach(p => { if (p.startsWith("is:")) parts.delete(p); }); }
                    if (filterPart.toLowerCase() !== "is:all") { parts.add(filterPart); }
                }
                this.searchQuery = Array.from(parts).join(" ");
                document.getElementById("searchAddInput").value = this.searchQuery;
                this.render();
            },

            addTask(text) {
                const task = this.parseTodoLine(text);
                if (!task || !task.text || !task.text.trim()) { return; }
                this.saveUndoState();
                this.tasks.push(task);
                this.saveToLocalStorage();
            },

            enterEditMode(taskElement) {
                const taskId = taskElement.dataset.taskId;
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                this.selectedTask = taskId;
                taskElement.parentElement.querySelectorAll(".selected").forEach(el => el.classList.remove("selected"));
                taskElement.classList.add("selected");
                const content = taskElement.querySelector(".task-inner-content");
                content.classList.add("hidden");
                const input = document.createElement("input");
                input.type = "text"; input.className = "edit-input"; input.value = task.raw;
                content.parentElement.appendChild(input);
                input.focus(); input.select();
                input.addEventListener("input", e => this.autocomplete.handleInput(e));
                input.addEventListener("keydown", e => {
                    if (this.autocomplete.handleKeydown(e)) { e.preventDefault(); return; }
                    if (e.key === "Enter") input.blur();
                    else if (e.key === "Escape") { input.removeEventListener("blur", saveCallback); this.render(); }
                });
                const saveCallback = () => {
                    this.autocomplete.hide();
                    const newValue = input.value.trim();
                    if (newValue && newValue !== task.raw) {
                        this.saveUndoState();
                        const updatedTask = this.parseTodoLine(newValue);
                        updatedTask.id = task.id;
                        if (task.creationDate && !updatedTask.creationDate) updatedTask.creationDate = task.creationDate;
                        const taskIndex = this.tasks.findIndex(t => t.id === taskId);
                        if (taskIndex !== -1) this.tasks[taskIndex] = updatedTask;
                        this.saveToLocalStorage();
                    }
                    this.render();
                };
                input.addEventListener("blur", saveCallback, { once: true });
            },

            setPriority(newPriority) {
                const task = this.tasks.find(t => t.id === this.selectedTask);
                if (!task) return;
                this.saveUndoState();
                let newRaw = task.raw.replace(/^\([A-Z]\)\s/, "");
                if (newPriority) newRaw = `(${newPriority}) ${newRaw}`;
                const updatedTask = this.parseTodoLine(newRaw);
                updatedTask.id = task.id;
                const taskIndex = this.tasks.findIndex(t => t.id === task.id);
                if (taskIndex !== -1) this.tasks[taskIndex] = updatedTask;
                this.saveToLocalStorage();
                this.render();
            },

            changePriority(direction) {
                const task = this.tasks.find(t => t.id === this.selectedTask);
                if (!task) return;
                const priorities = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
                const cycle = [null, ...priorities];
                const currentCycleIndex = cycle.indexOf(task.priority);
                let newIndex;
                if (direction > 0) { newIndex = (currentCycleIndex + 1) % cycle.length; }
                else { newIndex = (currentCycleIndex - 1 + cycle.length) % cycle.length; }
                const newPriority = cycle[newIndex];
                if (newPriority !== task.priority) { this.setPriority(newPriority); }
            },

            generateUniqueId: () => `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`,

            parseTodoLine(line) {
                const task = { id: this.generateUniqueId(), raw: line.trim(), completed: false, priority: null, completionDate: null, creationDate: null, text: "", projects: [], contexts: [], metadata: {} };
                let r = line.trim(); if (!r) return task;
                if (r.startsWith("x ")) { task.completed = true; r = r.substring(2); const d = r.match(/^\d{4}-\d{2}-\d{2}\s/); if (d && this.isValidDate(d[0].trim())) { task.completionDate = d[0].trim(); r = r.substring(d[0].length); } }
                const p = r.match(/^\(([A-Za-z])\)\s/); if (p) { task.priority = p[1].toUpperCase(); r = r.substring(p[0].length); }
                const c = r.match(/^\d{4}-\d{2}-\d{2}\s/); if (c && this.isValidDate(c[0].trim())) { task.creationDate = c[0].trim(); r = r.substring(c[0].length); }
                const proj = r.match(/\+[\w.-]+/g); if (proj) task.projects = [...new Set(proj.map(pr => pr.substring(1)))];
                const ctx = r.match(/@[\w.-]+/g); if (ctx) task.contexts = [...new Set(ctx.map(ct => ct.substring(1)))];
                const meta = r.match(/(\w+):([^\s]+)/g); if (meta) meta.forEach(pair => { const [key, ...val] = pair.split(":"); if (key && val.length) task.metadata[key] = val.join(":"); });
                task.text = r; return task;
            },

            isValidDate: (d) => /^\d{4}-\d{2}-\d{2}$/.test(d) && (new Date(d)).toISOString().startsWith(d),

            toggleTask(taskId) {
                const task = this.tasks.find(t => t.id === taskId); if (!task) return;
                this.saveUndoState(); task.completed = !task.completed;
                const today = (new Date).toISOString().split("T")[0];
                task.raw = task.raw.replace(/^x\s\d{4}-\d{2}-\d{2}\s/, "").trim();
                if (task.completed) { task.completionDate = today; task.raw = `x ${today} ${task.raw}`; this.showNotification("✅ Aufgabe erledigt!"); }
                else { task.completionDate = null; }
                this.saveToLocalStorage(); this.render();
            },

            deleteTask(taskId) {
                if (!confirm("Delete task?")) return;
                this.saveUndoState(); this.tasks = this.tasks.filter(t => t.id !== taskId);
                if (this.selectedTask === taskId) this.selectedTask = null;
                this.saveToLocalStorage(); this.render();
            },

            selectTask(taskId) { this.selectedTask = taskId; this.render(); },

            getFilteredTasks() {
                let baseTasks = [...this.tasks];
                const searchParts = this.searchQuery.toLowerCase().split(" ").filter(Boolean);
                let viewFilter = "all"; if (searchParts.includes("is:open")) viewFilter = "open"; else if (searchParts.includes("is:done")) viewFilter = "done";
                if (viewFilter === "open") baseTasks = baseTasks.filter(t => !t.completed); else if (viewFilter === "done") baseTasks = baseTasks.filter(t => t.completed);
                let filtered = baseTasks; if (searchParts.length > 0) { filtered = baseTasks.filter(task => { const taskText = task.raw.toLowerCase(); return searchParts.every(part => { if (part.startsWith("prio:")) return task.priority === part.split(":")[1].toUpperCase(); if (part.startsWith("+")) return task.projects.some(p => p.toLowerCase() === part.substring(1)); if (part.startsWith("@")) return task.contexts.some(c => c.toLowerCase() === part.substring(1)); if (part === "is:no-due") return !task.metadata.due; if (part === "is:no-project") return task.projects.length === 0; if (part === "is:no-context") return task.contexts.length === 0; if (part === "is:no-prio") return !task.priority; if (part.startsWith("is:")) return true; return taskText.includes(part); }); }); }
                if (this.selectedTask && !filtered.some(t => t.id === this.selectedTask)) this.selectedTask = null;
                return this.sortTasks(filtered);
            },

            sortTasks(tasks) {
                const sorted = [...tasks];
                switch (this.sortField) {
                    case "priority": sorted.sort((a, b) => (a.priority || "Z").localeCompare(b.priority || "Z")); break;
                    case "project": sorted.sort((a, b) => (a.projects[0] || "\uffff").localeCompare(b.projects[0] || "\uffff")); break;
                    case "context": sorted.sort((a, b) => (a.contexts[0] || "\uffff").localeCompare(b.contexts[0] || "\uffff")); break;
                    case "due": sorted.sort((a, b) => (a.metadata.due || "9999").localeCompare(b.metadata.due || "9999")); break;
                } return sorted;
            },

            getGroupValue: (t) => ({ priority: t.priority ? `Priority ${t.priority}` : "No Priority", project: t.projects[0] || "No Project", context: t.contexts[0] || "No Context", due: t.metadata.due || "No Due Date" })[this.sortField] || "",
            escapeHtml: (text = '') => text.replace(/[&<>"']/g, m => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" })[m]),

            render() {
                const taskListEl = document.getElementById("taskList");
                const emptyStateEl = document.getElementById("emptyState");
                const filteredTasks = this.getFilteredTasks();
                if (filteredTasks.length === 0) { taskListEl.innerHTML = ""; emptyStateEl.style.display = "block"; }
                else {
                    emptyStateEl.style.display = "none"; let prevGroup = null;
                    const regexEscape = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                    const html = filteredTasks.map(task => {
                        const currentGroup = this.getGroupValue(task);
                        const isNewGroup = this.sortField !== "default" && prevGroup !== currentGroup;
                        if (isNewGroup) prevGroup = currentGroup;
                        let displayText = this.escapeHtml(task.text);
                        task.projects.forEach(p => displayText = displayText.replace(new RegExp(`\\+${regexEscape(this.escapeHtml(p))}\\b`, "gi"), `<span class="project">+${this.escapeHtml(p)}</span>`));
                        task.contexts.forEach(c => displayText = displayText.replace(new RegExp(`@${regexEscape(this.escapeHtml(c))}\\b`, "gi"), `<span class="context">@${this.escapeHtml(c)}</span>`));
                        const meta = [task.creationDate, task.metadata.due, task.completionDate].filter(Boolean).join(" • ");
                        const groupHeader = isNewGroup ? `<h4 class="task-group-header">${this.escapeHtml(currentGroup)}</h4>` : "";
                        return `
                            ${groupHeader}
                            <div class="task-item ${this.selectedTask === task.id ? "selected" : ""} ${this.bulkSelected.has(task.id) ? "bulk-selected" : ""}" data-task-id="${task.id}" tabindex="-1">
                                <input type="checkbox" class="task-checkbox" ${task.completed ? "checked" : ""} aria-label="Toggle task: ${this.escapeHtml(task.text)}">
                                <div class="task-content">
                                    <div class="task-inner-content">
                                        <div class="task-text ${task.completed ? "completed" : ""}">${task.priority ? `<span class="priority priority-${task.priority}">(${task.priority})</span> ` : ""}${displayText}</div>
                                        ${meta ? `<div class="task-meta">${meta}</div>` : ""}
                                    </div>
                                </div>
                            </div>`;
                    }).join(""); taskListEl.innerHTML = html;
                } this.renderSidebar();
            },

            renderSidebar() {
                const countMap = (items) => items.reduce((acc, item) => { acc[item] = (acc[item] || 0) + 1; return acc; }, {});
                const priorities = countMap(this.tasks.map(t => t.priority).filter(Boolean)); const prioList = document.getElementById("prioritiesList"); if(prioList) prioList.innerHTML = Object.entries(priorities).sort().map(([p, c]) => `<div class="filter-item" data-priority="${p}"><span>(${p})</span><span class="filter-count">${c}</span></div>`).join("");
                const projects = countMap(this.tasks.flatMap(t => t.projects)); const projList = document.getElementById("projectsList"); if(projList) projList.innerHTML = Object.entries(projects).sort().map(([p, c]) => `<div class="filter-item" data-project="${this.escapeHtml(p)}"><span>+${this.escapeHtml(p)}</span><span class="filter-count">${c}</span></div>`).join("");
                const contexts = countMap(this.tasks.flatMap(t => t.contexts)); const ctxList = document.getElementById("contextsList"); if(ctxList) ctxList.innerHTML = Object.entries(contexts).sort().map(([c, count]) => `<div class="filter-item" data-context="${this.escapeHtml(c)}"><span>@${this.escapeHtml(c)}</span><span class="filter-count">${count}</span></div>`).join("");
                const currentFilters = new Set(this.searchQuery.toLowerCase().split(" ").filter(Boolean));
                document.querySelectorAll(".sidebar .filter-btn").forEach(el => { const { viewFilter, specialFilter } = el.dataset; let isActive = false; if (viewFilter) { const hasOpen = currentFilters.has("is:open"); const hasDone = currentFilters.has("is:done"); if (viewFilter === "all") isActive = !hasOpen && !hasDone; else if (viewFilter === "open") isActive = hasOpen; else if (viewFilter === "done") isActive = hasDone; } else if (specialFilter) isActive = currentFilters.has(`is:${specialFilter}`); el.classList.toggle("active", isActive); });
                document.querySelectorAll(".sidebar .filter-item").forEach(el => { const { priority, project, context } = el.dataset; let isActive = false; if (priority) isActive = currentFilters.has(`prio:${priority.toLowerCase()}`); else if (project) isActive = currentFilters.has(`+${project.toLowerCase()}`); else if (context) isActive = currentFilters.has(`@${context.toLowerCase()}`); el.classList.toggle("active", isActive); });
            },

            toggleBulkSelect(taskId) { this.bulkSelected.has(taskId) ? this.bulkSelected.delete(taskId) : this.bulkSelected.add(taskId); this.render(); this.updateBulkBar(); },
            bulkSelectAll() { this.getFilteredTasks().forEach(t => this.bulkSelected.add(t.id)); this.render(); this.updateBulkBar(); },
            bulkDeselectAll() { this.bulkSelected.clear(); this.render(); this.updateBulkBar(); },
            bulkComplete() { if (this.bulkSelected.size === 0) return; this.saveUndoState(); this.tasks.forEach(t => { if (this.bulkSelected.has(t.id)) this.toggleTask(t.id); }); const count = this.bulkSelected.size; this.bulkSelected.clear(); this.updateBulkBar(); this.showNotification(`✅ ${count} Aufgaben umgeschaltet`); },
            bulkDelete() { if (this.bulkSelected.size === 0 || !confirm(`Delete ${this.bulkSelected.size} task(s)?`)) return; this.saveUndoState(); const count = this.bulkSelected.size; this.tasks = this.tasks.filter(t => !this.bulkSelected.has(t.id)); if (this.selectedTask && this.bulkSelected.has(this.selectedTask)) this.selectedTask = null; this.bulkSelected.clear(); this.saveToLocalStorage(); this.render(); this.updateBulkBar(); this.showNotification(`🗑️ ${count} Aufgaben gelöscht`); },

            // KORREKTUR: navigateTasks verwendet focus()
            navigateTasks(direction) {
                 const filtered = this.getFilteredTasks(); if (filtered.length === 0) return;
                 const currentIndex = this.selectedTask ? filtered.findIndex(t => t.id === this.selectedTask) : -1;
                 const newIndex = (currentIndex + direction + filtered.length) % filtered.length;
                 const newTaskToSelect = filtered[newIndex];
                 this.selectTask(newTaskToSelect.id); // Wählt Task aus (ändert CSS-Klasse)
                 // Fokus auf das Element setzen (setTimeout für Rendering-Verzögerung)
                 setTimeout(() => {
                     const taskElement = document.querySelector(`[data-task-id="${newTaskToSelect.id}"]`);
                     if (taskElement) taskElement.focus();
                 }, 50);
            },

            updateBulkBar() { const bulkBar = document.getElementById("bulkBar"); const count = this.bulkSelected.size; if (count > 0) { bulkBar.classList.add("active"); document.getElementById("bulkCount").textContent = `${count} selected`; } else { bulkBar.classList.remove("active"); } },
            importFile(file) { if (!file || file.size > 1048576 && !confirm(`Large file (${(file.size / 1024 / 1024).toFixed(2)}MB). Continue?`)) return; const reader = new FileReader; reader.onload = e => { let content = e.target.result; if (content.charCodeAt(0) === 65279) content = content.slice(1); const lines = content.split("\n").filter(l => l.trim()); if (this.tasks.length > 0 && !confirm(`Import ${lines.length} tasks? (Will append)`)) return; this.saveUndoState(); this.tasks.push(...lines.map(l => this.parseTodoLine(l))); this.saveToLocalStorage(true); this.render(); this.showNotification(`✅ Imported ${lines.length} tasks`); }; reader.readAsText(file); },
            exportToFile() { if (this.tasks.length === 0) return alert("No tasks to export"); const content = this.tasks.map(t => t.raw).join("\n"); const blob = new Blob([content], { type: "text/plain;charset=utf-8" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `todo-${(new Date).toISOString().slice(0, 10)}.txt`; a.click(); URL.revokeObjectURL(url); },
            archiveCompleted() { const completed = this.tasks.filter(t => t.completed); if (completed.length === 0 || !confirm(`Archive ${completed.length} completed task(s)?`)) return; this.saveUndoState(); const content = completed.map(t => t.raw).join("\n"); const blob = new Blob([content], { type: "text/plain;charset=utf-8" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `done-${(new Date).toISOString().slice(0, 10)}.txt`; a.click(); URL.revokeObjectURL(url); this.tasks = this.tasks.filter(t => !t.completed); if (this.selectedTask && !this.tasks.some(t => t.id === this.selectedTask)) this.selectedTask = null; this.bulkSelected.clear(); this.saveToLocalStorage(); this.render(); this.updateBulkBar(); this.showNotification(`✅ Archived ${completed.length} tasks`); },
            clearLocalStorage() { if (confirm('Clear all local tasks?\n\nThis cannot be undone and will NOT affect your Google Drive file.')) { this.tasks = []; this.selectedTask = null; this.bulkSelected.clear(); this.undoStack = []; try { localStorage.removeItem('todoTxtTasks'); } catch (e) { console.error('Failed to remove tasks from localStorage:', e); } this.updateUndoButton(); this.render(); this.showNotification('🗑️ Local tasks cleared.'); } },
            saveUndoState() { this.undoStack.push(JSON.parse(JSON.stringify(this.tasks))); if (this.undoStack.length > this.maxUndoSize) this.undoStack.shift(); this.updateUndoButton(); },
            updateUndoButton() { const disabled = this.undoStack.length === 0; const undoBtnDesktop = document.getElementById("undoBtnDesktop"); const undoBtnMobile = document.getElementById("undoBtnMobile"); if (undoBtnDesktop) undoBtnDesktop.disabled = disabled; if (undoBtnMobile) undoBtnMobile.disabled = disabled; },
            undo() { if (this.undoStack.length === 0) return; this.tasks = this.undoStack.pop(); this.saveToLocalStorage(); this.render(); this.updateUndoButton(); },
            showHelp() { alert("KEYBOARD SHORTCUTS:\n\n/ - Focus search/add\n↑ ↓ - Navigate tasks\n← → - Change priority\ne - Edit selected\nx - Toggle done\np then A-Z - Set priority\n(Ctrl|Cmd)+Z - Undo\nDelete - Delete selected\nEsc - Clear search/filters\n\nSEARCH SYNTAX:\n\nprio:A\n+project\n@context\nis:open / is:done\nis:no-due"); },
            showNotification(message) { const el = document.createElement("div"); el.style.cssText = "position:fixed;top:70px;right:20px;background:var(--success);color:white;padding:12px 20px;border-radius:4px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:9999;animation:slideIn 0.3s ease-out;"; el.textContent = message; document.body.appendChild(el); setTimeout(() => { el.style.animation = "slideOut 0.3s ease-in forwards"; setTimeout(() => el.remove(), 300); }, 2500); },
            toggleMenu() { const menu = document.getElementById("menuPanel"); const burgerBtn = document.getElementById("burgerBtn"); const isOpen = menu.classList.toggle("menu-open"); burgerBtn.setAttribute("aria-expanded", isOpen); },

            async initGapiClient() { if (typeof gapi === "undefined") { console.error("GAPI script ist nicht geladen."); return; } console.log("Lade GAPI Client-Bibliothek..."); try { await new Promise((resolve, reject) => { gapi.load("client", { callback: resolve, onerror: reject, timeout: 5e3, ontimeout: reject }); }); console.log("GAPI Client-Bibliothek geladen. Lade Drive API-Definitionen..."); await gapi.client.load("https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"); this.gapiClient = gapi.client; console.log("GAPI Client (Drive) initialisiert."); } catch (error) { console.error("Fehler beim GAPI Init:", error); alert("Fehler: Google Drive API konnte nicht geladen werden."); } },
            initGisTokenClient(callback) { if (this.gisTokenClient) { callback && callback(); return; } if (typeof google === "undefined" || !google.accounts || !google.accounts.oauth2) { console.error("GIS script ist nicht geladen."); alert("Fehler: Google Login-Service konnte nicht geladen werden."); return; } console.log("Initialisiere GIS Token Client..."); try { this.gisTokenClient = google.accounts.oauth2.initTokenClient({ client_id: this.CLIENT_ID, scope: this.DRIVE_SCOPE, callback: tokenResponse => { if (tokenResponse.error) { console.error("GIS Error:", tokenResponse.error); alert(`Login-Fehler: ${tokenResponse.error}`); return; } if (this.gapiClient) { this.gapiClient.setToken(tokenResponse); console.log("GIS Token an GAPI übergeben."); } else { console.error("GAPI Client nicht bereit, Token kann nicht gesetzt werden."); alert("Fehler: Drive-Client nicht bereit."); return; } console.log("GIS Login erfolgreich, Token erhalten."); this.updateSyncUI(true); this.findOrCreateDriveFile(); } }); console.log("GIS Token Client initialisiert."); callback && callback(); } catch (error) { console.error("Fehler beim GIS Init:", error); alert("Fehler beim Initialisieren des Google Logins."); } },
            async handleAuthClick() { if (typeof gapi === "undefined" || typeof google === "undefined") { alert("Google-API-Skripte sind noch nicht geladen. Bitte Moment warten und erneut klicken."); return; } if (!this.gapiClient) { console.log("User-Klick: Initialisiere GAPI (Drive) Client..."); await this.initGapiClient(); if (!this.gapiClient) { console.error("GAPI Client-Initialisierung fehlgeschlagen. Breche ab."); return; } } if (!this.gisTokenClient) { console.log("GAPI ist bereit. Initialisiere GIS (Login) Client..."); this.initGisTokenClient(() => { console.log("GIS ist bereit. Fordere Token an..."); this.gisTokenClient.requestAccessToken(); }); } else { console.log("GAPI und GIS sind bereit. Fordere Token an..."); this.gisTokenClient.requestAccessToken(); } },
            updateSyncUI(isLoggedIn) { const displayStyle = isLoggedIn ? 'none' : 'inline-block'; const loggedInDisplayStyle = isLoggedIn ? 'inline-block' : 'none'; ['gdriveLoginBtn', 'gdrivePushBtn', 'gdrivePullBtn'].forEach(idBase => { const desktopEl = document.getElementById(idBase + 'Desktop'); const mobileEl = document.getElementById(idBase + 'Mobile'); const style = idBase === 'gdriveLoginBtn' ? displayStyle : loggedInDisplayStyle; if (desktopEl) desktopEl.style.display = style; if (mobileEl) mobileEl.style.display = style; }); },
            async findOrCreateDriveFile() { if (!this.gapiClient) { console.warn("GAPI nicht bereit für Dateisuche."); return; } console.log("Suche nach todo.txt in appDataFolder..."); try { const response = await this.gapiClient.drive.files.list({ spaces: "appDataFolder", fields: "files(id, name)", q: "name='todo.txt'" }); const files = response.result.files; if (files && files.length > 0) { this.DRIVE_FILE_ID = files[0].id; console.log(`Datei gefunden mit ID: ${this.DRIVE_FILE_ID}`); } else { console.log("Keine todo.txt gefunden. Erstelle neue Datei..."); const createResponse = await this.gapiClient.drive.files.create({ resource: { name: "todo.txt", parents: ["appDataFolder"] }, fields: "id" }); this.DRIVE_FILE_ID = createResponse.result.id; console.log(`Neue Datei erstellt mit ID: ${this.DRIVE_FILE_ID}`); } } catch (error) { console.error("Fehler beim Suchen/Erstellen der Drive-Datei:", error); } },
            async pushToDrive() { if (!this.DRIVE_FILE_ID) { alert("Fehler: Keine Datei-ID. Bitte neu verbinden."); return; } if (!this.gapiClient) { alert("Fehler: GAPI Client nicht bereit."); return; } if (!confirm("Lokale Daten ➔ Google Drive speichern?\n(Überschreibt die Cloud-Version)")) return; console.log(`PUSH zu GDrive ${this.DRIVE_FILE_ID}...`); const content = this.tasks.map(t => t.raw).join("\n"); try { await this.gapiClient.request({ path: `/upload/drive/v3/files/${this.DRIVE_FILE_ID}`, method: "PATCH", params: { uploadType: "media" }, body: content }); this.showNotification("✅ In Google Drive gespeichert"); } catch (e) { console.error("Fehler beim PUSH:", e); } },
            async pullFromDrive() { if (!this.DRIVE_FILE_ID) { alert("Fehler: Keine Datei-ID. Bitte neu verbinden."); return; } if (!this.gapiClient) { alert("Fehler: GAPI Client nicht bereit."); return; } if (this.tasks.length > 0 && !confirm("Google Drive ➔ Lokale Daten laden?\n(Überschreibt alle ungespeicherten lokalen Änderungen)")) return; console.log(`PULL von GDrive ${this.DRIVE_FILE_ID}...`); try { const response = await this.gapiClient.drive.files.get({ fileId: this.DRIVE_FILE_ID, alt: "media" }); const content = response.body; this.saveUndoState(); if (content) { this.tasks = content.split("\n").filter(l => l.trim()).map(l => this.parseTodoLine(l)); } else { this.tasks = []; } this.saveToLocalStorage(true); this.render(); this.showNotification("✅ Von Google Drive geladen"); } catch (e) { console.error("Fehler beim PULL:", e); } },

            // --- autocomplete OBJEKT ---
            autocomplete: {
                app: null, // Referenz zur Haupt-App
                activeSuggestion: null, // Speichert den aktuell vorgeschlagenen Text-Teil
                lastUserInput: '', // Speichert, was der User zuletzt tippte

                init(mainApp) {
                    this.app = mainApp;
                    // Keine UI-Elemente mehr zu initialisieren
                },

                // Wird bei jedem Tastendruck im Input aufgerufen
                handleInput(e) {
                    const input = e.target;
                    const value = input.value;
                    const cursorPos = input.selectionStart;

                    // Nur vorschlagen, wenn der Cursor am Ende ist
                    if (cursorPos !== value.length) {
                         this.clearSuggestion(input);
                         this.lastUserInput = value; // Update user input tracker
                         return;
                    }

                    // Prüfen, ob der letzte Teil wie +tag oder @tag aussieht
                    const match = value.match(/([+@])([\w.-]*)$/);

                    if (match && match[2].length > 0) { // Nur suchen, wenn mind. 1 Zeichen nach +/@
                        const trigger = match[1];
                        const query = match[2];
                        const baseInput = value.substring(0, value.length - query.length); // Der Teil vor dem Query

                        const source = trigger === '+' ? this.app.tasks.flatMap(t => t.projects) : this.app.tasks.flatMap(t => t.contexts);
                        const suggestions = [...new Set(source)]
                            .filter(item => item.toLowerCase().startsWith(query.toLowerCase()))
                            .sort();

                        if (suggestions.length > 0) {
                            const bestSuggestion = suggestions[0]; // Nimm den ersten Treffer
                            // Nur vorschlagen, wenn der Vorschlag länger ist als die Eingabe
                            if (bestSuggestion.length > query.length) {
                                const suggestionPart = bestSuggestion.substring(query.length); // Der Teil, der ergänzt wird
                                this.activeSuggestion = suggestionPart;
                                this.lastUserInput = value; // Merken, was der User tippte

                                // Wert im Input aktualisieren und Vorschlag selektieren
                                input.value = baseInput + bestSuggestion;
                                input.setSelectionRange(value.length, input.value.length); // Selektiert den suggestionPart
                                return; // Vorschlag angezeigt, fertig für dieses Input-Event
                            }
                        }
                    }

                    // Wenn kein Vorschlag (mehr) passt oder kein Trigger
                    this.clearSuggestion(input);
                    this.lastUserInput = value; // Update user input tracker
                },

                // Wird bei Keydown im Input aufgerufen
                handleKeydown(e) {
                    const input = e.target;

                    // TAB zum Akzeptieren
                    if (e.key === 'Tab' && this.activeSuggestion) {
                         // Prüfen, ob der selektierte Text dem Vorschlag entspricht
                        const currentSelection = input.value.substring(input.selectionStart, input.selectionEnd);
                        if (currentSelection === this.activeSuggestion || input.selectionStart !== input.selectionEnd) { // Zweite Bedingung als Fallback
                            e.preventDefault(); // Standard-Tab verhindern
                            // Cursor ans Ende setzen (Selektion aufheben)
                            input.setSelectionRange(input.value.length, input.value.length);
                            this.clearSuggestion(input, false); // Nur internen Status löschen, nicht Input-Wert
                            // Optional: Leerzeichen anhängen?
                            // input.value += ' ';
                            // input.setSelectionRange(input.value.length, input.value.length);
                            this.app.searchQuery = input.value; // Wichtig: App-Status aktualisieren
                            return true; // Keydown wurde behandelt
                        }
                    }

                    // Pfeil rechts zum Akzeptieren (optional, aber oft intuitiv)
                    if (e.key === 'ArrowRight' && this.activeSuggestion && input.selectionStart === input.value.length) {
                         e.preventDefault();
                         input.setSelectionRange(input.value.length, input.value.length);
                         this.clearSuggestion(input, false);
                         this.app.searchQuery = input.value;
                         return true;
                    }


                    // Wenn eine andere Taste gedrückt wird (außerhalb der normalen Eingabe, die 'input' auslöst)
                    // oder der User im Text navigiert -> Vorschlag löschen
                     if (this.activeSuggestion && !['Shift', 'Control', 'Alt', 'Meta', 'Tab', 'ArrowRight'].includes(e.key) && input.selectionStart !== input.selectionEnd ) {
                         // Erwarte, dass das nächste 'input' Event den Vorschlag korrekt neu berechnet
                         // Es ist oft sicherer, hier nichts zu tun und auf das Input-Event zu warten.
                     }
                    // Wichtig: Wenn Backspace gedrückt wird, während Vorschlag aktiv ist -> nur Vorschlag löschen
                     if (e.key === 'Backspace' && this.activeSuggestion && input.selectionStart !== input.selectionEnd && input.selectionStart > this.lastUserInput.length) {
                          e.preventDefault();
                          input.value = this.lastUserInput; // Zurück zum User-Input
                          input.setSelectionRange(input.value.length, input.value.length); // Cursor ans Ende
                          this.clearSuggestion(input, false);
                          this.app.searchQuery = input.value;
                          // Trigger input event manually? No, browser should handle it.
                          // Manually trigger input event might be needed if browser behaves unexpectedly
                          // input.dispatchEvent(new Event('input', { bubbles: true }));
                          return true; // Verhindert weiteres Backspace-Verhalten
                     }


                    return false; // Keydown wurde nicht speziell behandelt
                },

                // Hilfsfunktion zum Löschen des Vorschlagsstatus
                clearSuggestion(input, shouldClearInputValue = false) {
                    if (shouldClearInputValue && this.activeSuggestion) {
                        // Implementierung, falls benötigt (z.B. bei Escape?)
                        // input.value = this.lastUserInput; // Geht zurück zum User-Input
                        // input.setSelectionRange(input.value.length, input.value.length);
                    }
                    this.activeSuggestion = null;
                     // Sicherstellen, dass keine Selektion mehr aktiv ist, wenn kein Vorschlag da ist
                     // Deaktiviert, da es beim normalen Tippen stören kann
                    // if (input.selectionStart !== input.selectionEnd && !this.activeSuggestion) {
                    //     input.setSelectionRange(input.value.length, input.value.length);
                    // }
                }
            },
            // --- ENDE autocomplete OBJEKT ---
            
        };

        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
